练习 1.7
=============

先将书本 16 页的 ``sqrt`` 函数完整敲下来：

.. literalinclude:: code/p16-sqrt.scm

然后使用 ``sqrt`` 函数进行实验测试：

::

    1 ]=> (sqrt 0.00009)                                    ; 应该是 0.003 而不是 0.03

    ;Value: .03220324381282134

    1 ]=> (sqrt 90000000000000000000000000000000000000000)  ; 对于大数没有问题

    ;Value: 3e20

可以发现，对于特别小的数，比如 ``(sqrt 0.00009)`` ，计算所给出的精度只能到前两位，这是因为在 ``good-enough?`` 中使用 ``0.001`` 作为检测精度造成的问题。

要避免检测受到指定精度的限制，我们按照练习所说，对 ``good-enough?`` 进行修改，不再检测猜测值 ``guess`` 的平方与 ``x`` 之间的差，而是检查新旧两次猜测值之间的差。

新的 ``good-enough?`` 定义如下：

.. literalinclude:: code/7-good-enough.scm

使用新的 ``good-enough?`` 重新定义 ``sqrt`` 函数，大部分的函数定义和原来的一样，只是 ``sqrt-iter`` 和 ``good-enough?`` 两个函数更改了：

.. literalinclude:: code/7-sqrt.scm

新的 ``sqrt`` 函数即使在测试非常小的值的时候都不会出现错误了：

::

    1 ]=> (sqrt 0.0009)

    ;Value: 3.0000012746348552e-2

但是，事实上，即使这个新的 ``sqrt`` 也并非完美，假如我们继续缩小 ``sqrt`` 的实参，比如说，调用 ``(sqrt 0.00009)`` ，那么新的 ``sqrt`` 将会再次出错：

::

    1 ]=> (sqrt 0.00009)

    ;Value: 9.487978730289174e-3

不过这次的出错原因和之前的出错原因不同：这次出错是因为计算所需的精度超出了解释器实现对浮点数精度的支持，和程序本身（的正确性）无关。

这也可以看出，即使程序被正确地写出来，但最终计算的精度还是会被解释器的实现所限制。

.. note:: 练习原本要求我们对比新旧两个猜测值之间的比率，但是这里使用对比两个猜测值之间的差作为检测手段，其实结果都是类似的，而且对比比率这种想法比对比差要来得更糟糕，因为比率的精度更差，且计算比率所需的除法要比减法慢得多。

.. note:: 在新的 ``sqrt-iter`` 的定义中， ``(improve guess x)`` 被重复调用了多次，这是因为书本到这个练习为止还没有介绍 ``let`` 结构。

    以下是一个使用 ``let`` 结构重写的、无重复调用的 ``sqrt-iter`` ：

    ::

        (define (sqrt-iter old-guess x)
            (let ((new-guess (improve old-guess x)))
                (if (good-enough? old-guess new-guess)
                    new-guess
                    (sqrt-iter new-guess x))))
